
pwm_and_IR_with_Interrupts.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000004  00800100  00000542  000005d6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000542  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000091  00800104  00800104  000005da  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  000005dc  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000085  00000000  00000000  00000ca8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000080  00000000  00000000  00000d30  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000006f3  00000000  00000000  00000db0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000014e  00000000  00000000  000014a3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000037d  00000000  00000000  000015f1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000150  00000000  00000000  00001970  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000001fa  00000000  00000000  00001ac0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000251  00000000  00000000  00001cba  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 a9 01 	jmp	0x352	; 0x352 <__vector_1>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 c9 00 	jmp	0x192	; 0x192 <__vector_9>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 e4 00 	jmp	0x1c8	; 0x1c8 <__vector_18>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 22 01 	jmp	0x244	; 0x244 <__vector_20>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	e2 e4       	ldi	r30, 0x42	; 66
  7c:	f5 e0       	ldi	r31, 0x05	; 5
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	a4 30       	cpi	r26, 0x04	; 4
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	11 e0       	ldi	r17, 0x01	; 1
  8c:	a4 e0       	ldi	r26, 0x04	; 4
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	a5 39       	cpi	r26, 0x95	; 149
  96:	b1 07       	cpc	r27, r17
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 e0 01 	call	0x3c0	; 0x3c0 <main>
  9e:	0c 94 9f 02 	jmp	0x53e	; 0x53e <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <Init>:

void Init(void)
{
  a6:	cf 93       	push	r28
  a8:	df 93       	push	r29
  DDRB = 0xFF;	// PORTB the direction is defined as OUTPUT
  aa:	9f ef       	ldi	r25, 0xFF	; 255
  ac:	94 b9       	out	0x04, r25	; 4
  DDRD = 0xFA;	// PortD is defined as OUTPUT - P2D is INPUT (RC5 receive, via interrupt ) (PD0 = input = RxD UART)
  ae:	8a ef       	ldi	r24, 0xFA	; 250
  b0:	8a b9       	out	0x0a, r24	; 10
  PORTD &= ~(1 << PD2);
  b2:	5a 98       	cbi	0x0b, 2	; 11
    
  /* INT0 registers */
  EICRA = 0x02;              // set IRQ vlag on falling edge of INT0 (PD2 pin32).
  b4:	82 e0       	ldi	r24, 0x02	; 2
  b6:	80 93 69 00 	sts	0x0069, r24
  EIFR = 0x00;               // clear INT0 vlag
  ba:	1c ba       	out	0x1c, r1	; 28
  EIMSK = 0x01;              // enable INT0 interrupts
  bc:	81 e0       	ldi	r24, 0x01	; 1
  be:	8d bb       	out	0x1d, r24	; 29
  
  /* Timer1 registers */
  TCCR1A = 0x01;             // clear OCA0 and OCB0 on compare match.  Set on top.  Fast PWM 10-bit
  c0:	c0 e8       	ldi	r28, 0x80	; 128
  c2:	d0 e0       	ldi	r29, 0x00	; 0
  c4:	88 83       	st	Y, r24
  TCCR1C = 0x00;             // No prescaler
  c6:	10 92 82 00 	sts	0x0082, r1
  TCNT1 = 0;                 // timer1 = 0
  ca:	10 92 85 00 	sts	0x0085, r1
  ce:	10 92 84 00 	sts	0x0084, r1
  OCR1A = 0;                 // PWM A = 0
  d2:	a8 e8       	ldi	r26, 0x88	; 136
  d4:	b0 e0       	ldi	r27, 0x00	; 0
  d6:	11 96       	adiw	r26, 0x01	; 1
  d8:	1c 92       	st	X, r1
  da:	1e 92       	st	-X, r1
  OCR1B = 0;                 // PWM B = 0
  dc:	ea e8       	ldi	r30, 0x8A	; 138
  de:	f0 e0       	ldi	r31, 0x00	; 0
  e0:	11 82       	std	Z+1, r1	; 0x01
  e2:	10 82       	st	Z, r1
  TIFR1 = 0x00;              // clear Timer 1 vlag
  e4:	16 ba       	out	0x16, r1	; 22
  TIMSK1 = 0x00;             // disable all Timer 1 interrupts
  e6:	10 92 6f 00 	sts	0x006F, r1
  
  TCCR2A = 0x00;
  ea:	10 92 b0 00 	sts	0x00B0, r1
  TCCR2B = 0x03;			 // prescaler op 32  
  ee:	23 e0       	ldi	r18, 0x03	; 3
  f0:	20 93 b1 00 	sts	0x00B1, r18
  TCNT2 = 0xD2;				 // 89 us = 711 * 0,125us --> 711 / 32 = 22 --> 255-22 = 0xE9(Hex)
  f4:	22 ed       	ldi	r18, 0xD2	; 210
  f6:	20 93 b2 00 	sts	0x00B2, r18
  TIFR2 = 0x00;              // clear Timer 2 vlag
  fa:	17 ba       	out	0x17, r1	; 23
  TIMSK2 = 0x01;             // enable Timer 2 overflow interrupts
  fc:	80 93 70 00 	sts	0x0070, r24
			
  TCCR1A = 0xF0;	//bit7: compare output mode for compare unit A(COM1A1)
 100:	20 ef       	ldi	r18, 0xF0	; 240
 102:	28 83       	st	Y, r18
  //bit5: compare output mode for compare unit B(COM1B1)
  //bit4: compare output mode for compare unit B(COM1B0)
  //bit3:
  //bit2:
  //bit1:0 Waveform Generation Mode (WGM11:0)
  TCCR0A = 0xA3;	//bit7: compare output mode for compare unit A(COM1A1)
 104:	23 ea       	ldi	r18, 0xA3	; 163
 106:	24 bd       	out	0x24, r18	; 36
  //bit4: compare output mode for compare unit B(COM1B0)
  //bit3:
  //bit2:
  //bit1:0 Waveform Generation Mode (WGM11:0)
	
  TCCR1B = 0x11;	//bit7: Input Capture Noise Canceler(ICNC1
 108:	21 e1       	ldi	r18, 0x11	; 17
 10a:	20 93 81 00 	sts	0x0081, r18
  //bit6: Input Capture Edge Select(ICES1)
  //bit5: - Reserved bit
  //bit4:3 Waveform Generation Mode(WGM13:2)
  //bit2:0 Clock Select(CS12:0)
  TCCR0B = 0x01;	//bit4:3 Waveform Generation Mode(WGM13:2)
 10e:	85 bd       	out	0x25, r24	; 37
  //bit2:0 Clock Select(CS12:0)

  // defines the top values used in generating pwm for the servo motor
  ICR1H = 0xFF;
 110:	90 93 87 00 	sts	0x0087, r25
  ICR1L = 0xFF;
 114:	90 93 86 00 	sts	0x0086, r25
		
  // only used as the default values
  OCR1AH = 0x00;
 118:	10 92 89 00 	sts	0x0089, r1
  OCR1AL = 0x00;
 11c:	1c 92       	st	X, r1
  OCR1BH = 0x00;
 11e:	10 92 8b 00 	sts	0x008B, r1
  OCR1BL = 0x00;
 122:	10 82       	st	Z, r1
  OCR0B  = 0x00;
 124:	18 bc       	out	0x28, r1	; 40
  
  PORTB = 0x00;
 126:	15 b8       	out	0x05, r1	; 5

  /* USART 0 */
  UBRR0H = 0x00;						// 9600 bps (@ 8MHz)
 128:	10 92 c5 00 	sts	0x00C5, r1
  UBRR0L = 0x33;
 12c:	83 e3       	ldi	r24, 0x33	; 51
 12e:	80 93 c4 00 	sts	0x00C4, r24
  UCSR0B |= (1<<RXEN0)|(1<<TXEN0);		// receive and transmit Enable
 132:	e1 ec       	ldi	r30, 0xC1	; 193
 134:	f0 e0       	ldi	r31, 0x00	; 0
 136:	80 81       	ld	r24, Z
 138:	88 61       	ori	r24, 0x18	; 24
 13a:	80 83       	st	Z, r24
  UCSR0B |= (1 << RXCIE0); 				// USART Receive Complete interrupt
 13c:	80 81       	ld	r24, Z
 13e:	80 68       	ori	r24, 0x80	; 128
 140:	80 83       	st	Z, r24
  UCSR0B |= (1 << TXCIE0);				// Transmit Interrupt Complete Enabled
 142:	80 81       	ld	r24, Z
 144:	80 64       	ori	r24, 0x40	; 64
 146:	80 83       	st	Z, r24

  UCSR0C |= 0x06;						//8 databit, geen pariteit, 1 stopbit
 148:	e2 ec       	ldi	r30, 0xC2	; 194
 14a:	f0 e0       	ldi	r31, 0x00	; 0
 14c:	80 81       	ld	r24, Z
 14e:	86 60       	ori	r24, 0x06	; 6
 150:	80 83       	st	Z, r24
 152:	ef e4       	ldi	r30, 0x4F	; 79
 154:	f1 e0       	ldi	r31, 0x01	; 1
 156:	a2 e7       	ldi	r26, 0x72	; 114
 158:	b1 e0       	ldi	r27, 0x01	; 1

void Init(void)
 15a:	cf 01       	movw	r24, r30
 15c:	83 96       	adiw	r24, 0x23	; 35

  UCSR0C |= 0x06;						//8 databit, geen pariteit, 1 stopbit
    
  for(count = 0; count < 35; count++)
  {
	  Tx_buffer[count] = 0;
 15e:	11 92       	st	Z+, r1
	  Rx_buffer[count] = 0;	  
 160:	1d 92       	st	X+, r1
  UCSR0B |= (1 << RXCIE0); 				// USART Receive Complete interrupt
  UCSR0B |= (1 << TXCIE0);				// Transmit Interrupt Complete Enabled

  UCSR0C |= 0x06;						//8 databit, geen pariteit, 1 stopbit
    
  for(count = 0; count < 35; count++)
 162:	e8 17       	cp	r30, r24
 164:	f9 07       	cpc	r31, r25
 166:	d9 f7       	brne	.-10     	; 0x15e <Init+0xb8>
 168:	83 e2       	ldi	r24, 0x23	; 35
 16a:	90 e0       	ldi	r25, 0x00	; 0
 16c:	90 93 10 01 	sts	0x0110, r25
 170:	80 93 0f 01 	sts	0x010F, r24
  {
	  Tx_buffer[count] = 0;
	  Rx_buffer[count] = 0;	  
  }
  
  Rx_index = 1;
 174:	81 e0       	ldi	r24, 0x01	; 1
 176:	80 93 19 01 	sts	0x0119, r24
  Tx_index = 0;
 17a:	10 92 13 01 	sts	0x0113, r1
  last_Tx_byte = 0;
 17e:	10 92 35 01 	sts	0x0135, r1
  received = 0;
 182:	10 92 12 01 	sts	0x0112, r1
 186:	10 92 11 01 	sts	0x0111, r1
  sei ();                    // enable interrupts
 18a:	78 94       	sei
//  cli();					   // disable interrupts
}  /* i n i t */
 18c:	df 91       	pop	r29
 18e:	cf 91       	pop	r28
 190:	08 95       	ret

00000192 <__vector_9>:

ISR (TIMER2_OVF_vect)
{
 192:	1f 92       	push	r1
 194:	0f 92       	push	r0
 196:	0f b6       	in	r0, 0x3f	; 63
 198:	0f 92       	push	r0
 19a:	11 24       	eor	r1, r1
 19c:	8f 93       	push	r24
 19e:	9f 93       	push	r25
  TIFR2 = 0x00;                   // clear Timer 2 vlag
 1a0:	17 ba       	out	0x17, r1	; 23
  TCNT2 = 0xD2;					  // 88 us = 711 * 0,125us --> 711 / 32 = 22 --> 255-22 = 0xE9(Hex)
 1a2:	82 ed       	ldi	r24, 0xD2	; 210
 1a4:	80 93 b2 00 	sts	0x00B2, r24
  
  bit_cnt++;
 1a8:	80 91 07 01 	lds	r24, 0x0107
 1ac:	90 91 08 01 	lds	r25, 0x0108
 1b0:	01 96       	adiw	r24, 0x01	; 1
 1b2:	90 93 08 01 	sts	0x0108, r25
 1b6:	80 93 07 01 	sts	0x0107, r24
  {
	  PORTD &= ~(1 <<PD4);
	  test2 = 1;
  }
*/       
}   /* Timer_2 overflow  ISR */
 1ba:	9f 91       	pop	r25
 1bc:	8f 91       	pop	r24
 1be:	0f 90       	pop	r0
 1c0:	0f be       	out	0x3f, r0	; 63
 1c2:	0f 90       	pop	r0
 1c4:	1f 90       	pop	r1
 1c6:	18 95       	reti

000001c8 <__vector_18>:
}   /* c o n v e r s i o n _ r e a d y _ I S R */



ISR (USART_RX_vect)                // USART receive complete interrupt
{
 1c8:	1f 92       	push	r1
 1ca:	0f 92       	push	r0
 1cc:	0f b6       	in	r0, 0x3f	; 63
 1ce:	0f 92       	push	r0
 1d0:	11 24       	eor	r1, r1
 1d2:	8f 93       	push	r24
 1d4:	9f 93       	push	r25
 1d6:	ef 93       	push	r30
 1d8:	ff 93       	push	r31
	Rx_data = UDR0;
 1da:	80 91 c6 00 	lds	r24, 0x00C6
 1de:	80 93 1a 01 	sts	0x011A, r24
	if (Rx_data == STX)
 1e2:	82 30       	cpi	r24, 0x02	; 2
 1e4:	49 f4       	brne	.+18     	; 0x1f8 <__vector_18+0x30>
	{
	  PORTD |= (1 << PD3);
 1e6:	5b 9a       	sbi	0x0b, 3	; 11

	  Rx_index = 1;
 1e8:	81 e0       	ldi	r24, 0x01	; 1
 1ea:	80 93 19 01 	sts	0x0119, r24
	  Rx_buffer[Rx_index] = Rx_data;
 1ee:	80 91 1a 01 	lds	r24, 0x011A
 1f2:	80 93 73 01 	sts	0x0173, r24
 1f6:	1d c0       	rjmp	.+58     	; 0x232 <__vector_18+0x6a>
	}	  
	else
	{
		if (Rx_data == ETX)
 1f8:	83 30       	cpi	r24, 0x03	; 3
 1fa:	79 f4       	brne	.+30     	; 0x21a <__vector_18+0x52>
		{
		  PORTD &= ~(1 << PD3);
 1fc:	5b 98       	cbi	0x0b, 3	; 11
		  Rx_buffer[Rx_index] = Rx_data;
 1fe:	80 91 19 01 	lds	r24, 0x0119
 202:	e2 e7       	ldi	r30, 0x72	; 114
 204:	f1 e0       	ldi	r31, 0x01	; 1
 206:	e8 0f       	add	r30, r24
 208:	f1 1d       	adc	r31, r1
 20a:	90 91 1a 01 	lds	r25, 0x011A
 20e:	90 83       	st	Z, r25
		  received = Rx_index;   // command_received points to the last position in Rx_buffer 		  
 210:	80 93 11 01 	sts	0x0111, r24
 214:	10 92 12 01 	sts	0x0112, r1
 218:	0c c0       	rjmp	.+24     	; 0x232 <__vector_18+0x6a>
		}		  
		else
		{
			Rx_buffer[Rx_index] = Rx_data;
 21a:	90 91 19 01 	lds	r25, 0x0119
 21e:	e2 e7       	ldi	r30, 0x72	; 114
 220:	f1 e0       	ldi	r31, 0x01	; 1
 222:	e9 0f       	add	r30, r25
 224:	f1 1d       	adc	r31, r1
 226:	80 83       	st	Z, r24
			if (Rx_index < 30)
 228:	9e 31       	cpi	r25, 0x1E	; 30
 22a:	18 f4       	brcc	.+6      	; 0x232 <__vector_18+0x6a>
				Rx_index++;
 22c:	9f 5f       	subi	r25, 0xFF	; 255
 22e:	90 93 19 01 	sts	0x0119, r25
	  }
	}
}
 232:	ff 91       	pop	r31
 234:	ef 91       	pop	r30
 236:	9f 91       	pop	r25
 238:	8f 91       	pop	r24
 23a:	0f 90       	pop	r0
 23c:	0f be       	out	0x3f, r0	; 63
 23e:	0f 90       	pop	r0
 240:	1f 90       	pop	r1
 242:	18 95       	reti

00000244 <__vector_20>:


ISR (USART_TX_vect)               // USART transmit complete interrupt
{
 244:	1f 92       	push	r1
 246:	0f 92       	push	r0
 248:	0f b6       	in	r0, 0x3f	; 63
 24a:	0f 92       	push	r0
 24c:	11 24       	eor	r1, r1
 24e:	2f 93       	push	r18
 250:	8f 93       	push	r24
 252:	9f 93       	push	r25
 254:	ef 93       	push	r30
 256:	ff 93       	push	r31
  if (last_Tx_byte)
 258:	80 91 35 01 	lds	r24, 0x0135
 25c:	88 23       	and	r24, r24
 25e:	19 f0       	breq	.+6      	; 0x266 <__vector_20+0x22>
  {
//	    UCSR0B &= 0x40;                    // disable transmit interrupt
	    last_Tx_byte = 0;
 260:	10 92 35 01 	sts	0x0135, r1
 264:	1f c0       	rjmp	.+62     	; 0x2a4 <__vector_20+0x60>
  }
  else
  {
    UDR0 = Tx_buffer[Tx_index];
 266:	80 91 13 01 	lds	r24, 0x0113
 26a:	ef e4       	ldi	r30, 0x4F	; 79
 26c:	f1 e0       	ldi	r31, 0x01	; 1
 26e:	e8 0f       	add	r30, r24
 270:	f1 1d       	adc	r31, r1
 272:	90 81       	ld	r25, Z
 274:	90 93 c6 00 	sts	0x00C6, r25

	if ( (Tx_buffer[Tx_index] == ETX) || (Tx_index >= 35) )
 278:	90 81       	ld	r25, Z
 27a:	93 30       	cpi	r25, 0x03	; 3
 27c:	19 f0       	breq	.+6      	; 0x284 <__vector_20+0x40>
 27e:	83 32       	cpi	r24, 0x23	; 35
 280:	60 f4       	brcc	.+24     	; 0x29a <__vector_20+0x56>
 282:	07 c0       	rjmp	.+14     	; 0x292 <__vector_20+0x4e>
  	{
	    last_Tx_byte = 1;
 284:	91 e0       	ldi	r25, 0x01	; 1
 286:	90 93 35 01 	sts	0x0135, r25
	    command_transmitted = 1;
 28a:	90 93 1b 01 	sts	0x011B, r25
	}
    
	if (Tx_index < 35)
 28e:	83 32       	cpi	r24, 0x23	; 35
 290:	48 f4       	brcc	.+18     	; 0x2a4 <__vector_20+0x60>
	{
      Tx_index++;
 292:	8f 5f       	subi	r24, 0xFF	; 255
 294:	80 93 13 01 	sts	0x0113, r24
 298:	05 c0       	rjmp	.+10     	; 0x2a4 <__vector_20+0x60>
  {
    UDR0 = Tx_buffer[Tx_index];

	if ( (Tx_buffer[Tx_index] == ETX) || (Tx_index >= 35) )
  	{
	    last_Tx_byte = 1;
 29a:	81 e0       	ldi	r24, 0x01	; 1
 29c:	80 93 35 01 	sts	0x0135, r24
	    command_transmitted = 1;
 2a0:	80 93 1b 01 	sts	0x011B, r24
	if (Tx_index < 35)
	{
      Tx_index++;
	}	  
  }
}
 2a4:	ff 91       	pop	r31
 2a6:	ef 91       	pop	r30
 2a8:	9f 91       	pop	r25
 2aa:	8f 91       	pop	r24
 2ac:	2f 91       	pop	r18
 2ae:	0f 90       	pop	r0
 2b0:	0f be       	out	0x3f, r0	; 63
 2b2:	0f 90       	pop	r0
 2b4:	1f 90       	pop	r1
 2b6:	18 95       	reti

000002b8 <rc5_decode>:

// LINK = www.martinhubacek.cz/atmel/ir-remote-control-decoder

void rc5_decode(void)
{
	if(bit_nr < 12)
 2b8:	80 91 09 01 	lds	r24, 0x0109
 2bc:	90 91 0a 01 	lds	r25, 0x010A
 2c0:	8c 30       	cpi	r24, 0x0C	; 12
 2c2:	91 05       	cpc	r25, r1
 2c4:	a0 f5       	brcc	.+104    	; 0x32e <rc5_decode+0x76>
	{
		bit_cnt = 0;		
 2c6:	10 92 08 01 	sts	0x0108, r1
 2ca:	10 92 07 01 	sts	0x0107, r1
		while(IR_LOW)
 2ce:	4a 99       	sbic	0x09, 2	; 9
 2d0:	03 c0       	rjmp	.+6      	; 0x2d8 <rc5_decode+0x20>
		{
			PORTD |= (1 << PD4);
 2d2:	5c 9a       	sbi	0x0b, 4	; 11
void rc5_decode(void)
{
	if(bit_nr < 12)
	{
		bit_cnt = 0;		
		while(IR_LOW)
 2d4:	4a 9b       	sbis	0x09, 2	; 9
 2d6:	fd cf       	rjmp	.-6      	; 0x2d2 <rc5_decode+0x1a>
		{
			PORTD |= (1 << PD4);
		}

		bit_time_low[bit_nr] = bit_cnt;
 2d8:	e0 91 09 01 	lds	r30, 0x0109
 2dc:	f0 91 0a 01 	lds	r31, 0x010A
 2e0:	ee 0f       	add	r30, r30
 2e2:	ff 1f       	adc	r31, r31
 2e4:	ea 5c       	subi	r30, 0xCA	; 202
 2e6:	fe 4f       	sbci	r31, 0xFE	; 254
 2e8:	80 91 07 01 	lds	r24, 0x0107
 2ec:	90 91 08 01 	lds	r25, 0x0108
 2f0:	91 83       	std	Z+1, r25	; 0x01
 2f2:	80 83       	st	Z, r24
		
		bit_cnt = 0;
 2f4:	10 92 08 01 	sts	0x0108, r1
 2f8:	10 92 07 01 	sts	0x0107, r1
		while(IR_HIGH)
 2fc:	4a 9b       	sbis	0x09, 2	; 9
 2fe:	03 c0       	rjmp	.+6      	; 0x306 <rc5_decode+0x4e>
		{
			PORTD &= ~(1 << PD4);			
 300:	5c 98       	cbi	0x0b, 4	; 11
		}

		bit_time_low[bit_nr] = bit_cnt;
		
		bit_cnt = 0;
		while(IR_HIGH)
 302:	4a 99       	sbic	0x09, 2	; 9
 304:	fd cf       	rjmp	.-6      	; 0x300 <rc5_decode+0x48>
		{
			PORTD &= ~(1 << PD4);			
		}
		bit_time_high[bit_nr] = bit_cnt;
 306:	80 91 09 01 	lds	r24, 0x0109
 30a:	90 91 0a 01 	lds	r25, 0x010A
 30e:	fc 01       	movw	r30, r24
 310:	ee 0f       	add	r30, r30
 312:	ff 1f       	adc	r31, r31
 314:	e4 5e       	subi	r30, 0xE4	; 228
 316:	fe 4f       	sbci	r31, 0xFE	; 254
 318:	20 91 07 01 	lds	r18, 0x0107
 31c:	30 91 08 01 	lds	r19, 0x0108
 320:	31 83       	std	Z+1, r19	; 0x01
 322:	20 83       	st	Z, r18
		
		bit_nr++;
 324:	01 96       	adiw	r24, 0x01	; 1
 326:	90 93 0a 01 	sts	0x010A, r25
 32a:	80 93 09 01 	sts	0x0109, r24
	}
	
	if(bit_nr == 11)
 32e:	80 91 09 01 	lds	r24, 0x0109
 332:	90 91 0a 01 	lds	r25, 0x010A
 336:	8b 30       	cpi	r24, 0x0B	; 11
 338:	91 05       	cpc	r25, r1
 33a:	21 f4       	brne	.+8      	; 0x344 <rc5_decode+0x8c>
		bit_nr = 0;
 33c:	10 92 0a 01 	sts	0x010A, r1
 340:	10 92 09 01 	sts	0x0109, r1
 344:	08 95       	ret

00000346 <get_RC5>:
	int16_t tmp;
	int16_t d_t;
	int8_t i;
	int8_t inp;

	TCNT2 = 0;                  // reset timer
 346:	e2 eb       	ldi	r30, 0xB2	; 178
 348:	f0 e0       	ldi	r31, 0x00	; 0
 34a:	10 82       	st	Z, r1
	while(IR_STATUS == 1);
	d_t = TCNT2;
 34c:	80 81       	ld	r24, Z
	RC5.state = 1;         // set flag for successful IR command decoding

	TIMSK2 &= ~(1 << TOIE2);      // disable Interrupts until received command has been processed
	EIMSK &= ~(1 << INT0);		  // disable External interrupt
	return 1;
}
 34e:	80 e0       	ldi	r24, 0x00	; 0
 350:	08 95       	ret

00000352 <__vector_1>:
}   /* Timer_2 overflow  ISR */



ISR (INT0_vect)
{
 352:	1f 92       	push	r1
 354:	0f 92       	push	r0
 356:	0f b6       	in	r0, 0x3f	; 63
 358:	0f 92       	push	r0
 35a:	11 24       	eor	r1, r1
 35c:	2f 93       	push	r18
 35e:	3f 93       	push	r19
 360:	4f 93       	push	r20
 362:	5f 93       	push	r21
 364:	6f 93       	push	r22
 366:	7f 93       	push	r23
 368:	8f 93       	push	r24
 36a:	9f 93       	push	r25
 36c:	af 93       	push	r26
 36e:	bf 93       	push	r27
 370:	ef 93       	push	r30
 372:	ff 93       	push	r31
//	rc5_decode();
	if (test3)
 374:	80 91 0b 01 	lds	r24, 0x010B
 378:	90 91 0c 01 	lds	r25, 0x010C
 37c:	00 97       	sbiw	r24, 0x00	; 0
 37e:	31 f0       	breq	.+12     	; 0x38c <__vector_1+0x3a>
	{
		PORTD &= ~(1 << PD4);
 380:	5c 98       	cbi	0x0b, 4	; 11
		test3 = 0;
 382:	10 92 0c 01 	sts	0x010C, r1
 386:	10 92 0b 01 	sts	0x010B, r1
 38a:	07 c0       	rjmp	.+14     	; 0x39a <__vector_1+0x48>
	}
	else
	{
		PORTD |= (1 << PD4);
 38c:	5c 9a       	sbi	0x0b, 4	; 11
		test3 = 1;
 38e:	81 e0       	ldi	r24, 0x01	; 1
 390:	90 e0       	ldi	r25, 0x00	; 0
 392:	90 93 0c 01 	sts	0x010C, r25
 396:	80 93 0b 01 	sts	0x010B, r24
	}		
	
	get_RC5();
 39a:	0e 94 a3 01 	call	0x346	; 0x346 <get_RC5>
}   /* c o n v e r s i o n _ r e a d y _ I S R */
 39e:	ff 91       	pop	r31
 3a0:	ef 91       	pop	r30
 3a2:	bf 91       	pop	r27
 3a4:	af 91       	pop	r26
 3a6:	9f 91       	pop	r25
 3a8:	8f 91       	pop	r24
 3aa:	7f 91       	pop	r23
 3ac:	6f 91       	pop	r22
 3ae:	5f 91       	pop	r21
 3b0:	4f 91       	pop	r20
 3b2:	3f 91       	pop	r19
 3b4:	2f 91       	pop	r18
 3b6:	0f 90       	pop	r0
 3b8:	0f be       	out	0x3f, r0	; 63
 3ba:	0f 90       	pop	r0
 3bc:	1f 90       	pop	r1
 3be:	18 95       	reti

000003c0 <main>:

int main(void)
{
 3c0:	cf 93       	push	r28
 3c2:	df 93       	push	r29
 3c4:	cd b7       	in	r28, 0x3d	; 61
 3c6:	de b7       	in	r29, 0x3e	; 62
 3c8:	2a 97       	sbiw	r28, 0x0a	; 10
 3ca:	0f b6       	in	r0, 0x3f	; 63
 3cc:	f8 94       	cli
 3ce:	de bf       	out	0x3e, r29	; 62
 3d0:	0f be       	out	0x3f, r0	; 63
 3d2:	cd bf       	out	0x3d, r28	; 61
    Init();
 3d4:	0e 94 53 00 	call	0xa6	; 0xa6 <Init>
		{
			PORTD |= (1 << PD3);	
			start = 0;
		}
		
		if(RC5.state == 1)
 3d8:	e6 e1       	ldi	r30, 0x16	; 22
 3da:	f1 e0       	ldi	r31, 0x01	; 1
			EIMSK |= (1 << INT0);	
		}
		
		if(received)
		{	
			Rx_index = 1;
 3dc:	21 e0       	ldi	r18, 0x01	; 1
														
			if(Rx_buffer[1] == FROMBEAGLE)
 3de:	0f 2e       	mov	r0, r31
 3e0:	f3 e7       	ldi	r31, 0x73	; 115
 3e2:	af 2e       	mov	r10, r31
 3e4:	f1 e0       	ldi	r31, 0x01	; 1
 3e6:	bf 2e       	mov	r11, r31
 3e8:	f0 2d       	mov	r31, r0
				OCR1BL = Rx_buffer[5];
				OCR0B  = Rx_buffer[6];
			}
						
			// Vul de Zend Buffer met ontvangen data
			Tx_buffer[0] = STX;
 3ea:	0f 2e       	mov	r0, r31
 3ec:	ff e4       	ldi	r31, 0x4F	; 79
 3ee:	cf 2e       	mov	r12, r31
 3f0:	f1 e0       	ldi	r31, 0x01	; 1
 3f2:	df 2e       	mov	r13, r31
 3f4:	f0 2d       	mov	r31, r0
 3f6:	32 e0       	ldi	r19, 0x02	; 2
			Tx_buffer[1] = FROMBEAGLE;
 3f8:	46 01       	movw	r8, r12
 3fa:	08 94       	sec
 3fc:	81 1c       	adc	r8, r1
 3fe:	91 1c       	adc	r9, r1
			Tx_buffer[2] = Rx_buffer[2];
 400:	66 24       	eor	r6, r6
 402:	77 24       	eor	r7, r7
 404:	68 94       	set
 406:	61 f8       	bld	r6, 1
 408:	6c 0c       	add	r6, r12
 40a:	7d 1c       	adc	r7, r13
			Tx_buffer[3] = Rx_buffer[3];
 40c:	0f 2e       	mov	r0, r31
 40e:	f3 e0       	ldi	r31, 0x03	; 3
 410:	4f 2e       	mov	r4, r31
 412:	55 24       	eor	r5, r5
 414:	f0 2d       	mov	r31, r0
 416:	4c 0c       	add	r4, r12
 418:	5d 1c       	adc	r5, r13
 41a:	84 e7       	ldi	r24, 0x74	; 116
 41c:	91 e0       	ldi	r25, 0x01	; 1
 41e:	01 96       	adiw	r24, 0x01	; 1
 420:	9a 87       	std	Y+10, r25	; 0x0a
 422:	89 87       	std	Y+9, r24	; 0x09
			Tx_buffer[4] = Rx_buffer[4];
 424:	22 24       	eor	r2, r2
 426:	33 24       	eor	r3, r3
 428:	68 94       	set
 42a:	22 f8       	bld	r2, 2
 42c:	2c 0c       	add	r2, r12
 42e:	3d 1c       	adc	r3, r13
 430:	44 e7       	ldi	r20, 0x74	; 116
 432:	51 e0       	ldi	r21, 0x01	; 1
 434:	4e 5f       	subi	r20, 0xFE	; 254
 436:	5f 4f       	sbci	r21, 0xFF	; 255
			Tx_buffer[5] = Rx_buffer[5];
 438:	d6 01       	movw	r26, r12
 43a:	15 96       	adiw	r26, 0x05	; 5
 43c:	ba 83       	std	Y+2, r27	; 0x02
 43e:	a9 83       	std	Y+1, r26	; 0x01
 440:	64 e7       	ldi	r22, 0x74	; 116
 442:	71 e0       	ldi	r23, 0x01	; 1
 444:	6d 5f       	subi	r22, 0xFD	; 253
 446:	7f 4f       	sbci	r23, 0xFF	; 255
			Tx_buffer[6] = Rx_buffer[6];
 448:	c6 01       	movw	r24, r12
 44a:	06 96       	adiw	r24, 0x06	; 6
 44c:	9c 83       	std	Y+4, r25	; 0x04
 44e:	8b 83       	std	Y+3, r24	; 0x03
 450:	04 e7       	ldi	r16, 0x74	; 116
 452:	11 e0       	ldi	r17, 0x01	; 1
 454:	0c 5f       	subi	r16, 0xFC	; 252
 456:	1f 4f       	sbci	r17, 0xFF	; 255
	
//			RC5_cmd = 0x10;
			Tx_buffer[7] = RC5_cmd;
 458:	d6 01       	movw	r26, r12
 45a:	17 96       	adiw	r26, 0x07	; 7
 45c:	be 83       	std	Y+6, r27	; 0x06
 45e:	ad 83       	std	Y+5, r26	; 0x05
			Tx_buffer[8] = ETX;
 460:	c6 01       	movw	r24, r12
 462:	08 96       	adiw	r24, 0x08	; 8
 464:	98 87       	std	Y+8, r25	; 0x08
 466:	8f 83       	std	Y+7, r24	; 0x07
 468:	0f 2e       	mov	r0, r31
 46a:	f3 e0       	ldi	r31, 0x03	; 3
 46c:	ff 2e       	mov	r15, r31
 46e:	f0 2d       	mov	r31, r0
{
    Init();
		
	while(1)
    {										
		if(start)
 470:	80 91 01 01 	lds	r24, 0x0101
 474:	90 91 02 01 	lds	r25, 0x0102
 478:	00 97       	sbiw	r24, 0x00	; 0
 47a:	29 f0       	breq	.+10     	; 0x486 <main+0xc6>
		{
			PORTD |= (1 << PD3);	
 47c:	5b 9a       	sbi	0x0b, 3	; 11
			start = 0;
 47e:	10 92 02 01 	sts	0x0102, r1
 482:	10 92 01 01 	sts	0x0101, r1
		}
		
		if(RC5.state == 1)
 486:	80 81       	ld	r24, Z
 488:	81 30       	cpi	r24, 0x01	; 1
 48a:	11 f4       	brne	.+4      	; 0x490 <main+0xd0>
		{
			RC5.state = 0;
 48c:	10 82       	st	Z, r1
			EIMSK |= (1 << INT0);	
 48e:	e8 9a       	sbi	0x1d, 0	; 29
		}
		
		if(received)
 490:	80 91 11 01 	lds	r24, 0x0111
 494:	90 91 12 01 	lds	r25, 0x0112
 498:	00 97       	sbiw	r24, 0x00	; 0
 49a:	51 f3       	breq	.-44     	; 0x470 <main+0xb0>
		{	
			Rx_index = 1;
 49c:	20 93 19 01 	sts	0x0119, r18
														
			if(Rx_buffer[1] == FROMBEAGLE)
 4a0:	d5 01       	movw	r26, r10
 4a2:	8c 91       	ld	r24, X
 4a4:	90 91 00 01 	lds	r25, 0x0100
 4a8:	89 17       	cp	r24, r25
 4aa:	c9 f4       	brne	.+50     	; 0x4de <main+0x11e>
			{				
				// update the registers with the new values
				OCR1AH = Rx_buffer[2];
 4ac:	a4 e7       	ldi	r26, 0x74	; 116
 4ae:	b1 e0       	ldi	r27, 0x01	; 1
 4b0:	8c 91       	ld	r24, X
 4b2:	a9 e8       	ldi	r26, 0x89	; 137
 4b4:	b0 e0       	ldi	r27, 0x00	; 0
 4b6:	8c 93       	st	X, r24
				OCR1AL = Rx_buffer[3];
 4b8:	a9 85       	ldd	r26, Y+9	; 0x09
 4ba:	ba 85       	ldd	r27, Y+10	; 0x0a
 4bc:	8c 91       	ld	r24, X
 4be:	a8 e8       	ldi	r26, 0x88	; 136
 4c0:	b0 e0       	ldi	r27, 0x00	; 0
 4c2:	8c 93       	st	X, r24
				OCR1BH = Rx_buffer[4];
 4c4:	da 01       	movw	r26, r20
 4c6:	8c 91       	ld	r24, X
 4c8:	ab e8       	ldi	r26, 0x8B	; 139
 4ca:	b0 e0       	ldi	r27, 0x00	; 0
 4cc:	8c 93       	st	X, r24
				OCR1BL = Rx_buffer[5];
 4ce:	db 01       	movw	r26, r22
 4d0:	8c 91       	ld	r24, X
 4d2:	aa e8       	ldi	r26, 0x8A	; 138
 4d4:	b0 e0       	ldi	r27, 0x00	; 0
 4d6:	8c 93       	st	X, r24
				OCR0B  = Rx_buffer[6];
 4d8:	d8 01       	movw	r26, r16
 4da:	8c 91       	ld	r24, X
 4dc:	88 bd       	out	0x28, r24	; 40
			}
						
			// Vul de Zend Buffer met ontvangen data
			Tx_buffer[0] = STX;
 4de:	d6 01       	movw	r26, r12
 4e0:	3c 93       	st	X, r19
			Tx_buffer[1] = FROMBEAGLE;
 4e2:	80 91 00 01 	lds	r24, 0x0100
 4e6:	d4 01       	movw	r26, r8
 4e8:	8c 93       	st	X, r24
			Tx_buffer[2] = Rx_buffer[2];
 4ea:	a4 e7       	ldi	r26, 0x74	; 116
 4ec:	b1 e0       	ldi	r27, 0x01	; 1
 4ee:	8c 91       	ld	r24, X
 4f0:	d3 01       	movw	r26, r6
 4f2:	8c 93       	st	X, r24
			Tx_buffer[3] = Rx_buffer[3];
 4f4:	a9 85       	ldd	r26, Y+9	; 0x09
 4f6:	ba 85       	ldd	r27, Y+10	; 0x0a
 4f8:	8c 91       	ld	r24, X
 4fa:	d2 01       	movw	r26, r4
 4fc:	8c 93       	st	X, r24
			Tx_buffer[4] = Rx_buffer[4];
 4fe:	da 01       	movw	r26, r20
 500:	8c 91       	ld	r24, X
 502:	d1 01       	movw	r26, r2
 504:	8c 93       	st	X, r24
			Tx_buffer[5] = Rx_buffer[5];
 506:	db 01       	movw	r26, r22
 508:	8c 91       	ld	r24, X
 50a:	a9 81       	ldd	r26, Y+1	; 0x01
 50c:	ba 81       	ldd	r27, Y+2	; 0x02
 50e:	8c 93       	st	X, r24
			Tx_buffer[6] = Rx_buffer[6];
 510:	d8 01       	movw	r26, r16
 512:	8c 91       	ld	r24, X
 514:	ab 81       	ldd	r26, Y+3	; 0x03
 516:	bc 81       	ldd	r27, Y+4	; 0x04
 518:	8c 93       	st	X, r24
	
//			RC5_cmd = 0x10;
			Tx_buffer[7] = RC5_cmd;
 51a:	80 91 06 01 	lds	r24, 0x0106
 51e:	ad 81       	ldd	r26, Y+5	; 0x05
 520:	be 81       	ldd	r27, Y+6	; 0x06
 522:	8c 93       	st	X, r24
			Tx_buffer[8] = ETX;
 524:	af 81       	ldd	r26, Y+7	; 0x07
 526:	b8 85       	ldd	r27, Y+8	; 0x08
 528:	fc 92       	st	X, r15
			
			received = 0;
 52a:	10 92 12 01 	sts	0x0112, r1
 52e:	10 92 11 01 	sts	0x0111, r1
			Tx_index = 1;			
 532:	20 93 13 01 	sts	0x0113, r18
			// Verzend de Transmit Buffer
			UDR0 = STX;  // start transmission									
 536:	a6 ec       	ldi	r26, 0xC6	; 198
 538:	b0 e0       	ldi	r27, 0x00	; 0
 53a:	3c 93       	st	X, r19
 53c:	99 cf       	rjmp	.-206    	; 0x470 <main+0xb0>

0000053e <_exit>:
 53e:	f8 94       	cli

00000540 <__stop_program>:
 540:	ff cf       	rjmp	.-2      	; 0x540 <__stop_program>
